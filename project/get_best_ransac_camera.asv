% Loop over all the images and exract ransac best cameras and inliers.
% Maybe not loop  over all?
function [P_best, inliers] = get_best_ransac_camera(obj_idx, threshold, U, u, n_iterations)
    n_inliers_max = -1;
    P_best = [];
    
    
    
    root_error = @(x, y) (sum((x-y).^2)).^(0.5);

    for i = 1:n_iterations 
        % Get candidate cameras
        n_points = size(U{obj_idx}, 2);
        ind = randsample(n_points, 4); % 11 degrees of freedom?
        P = resection(U{obj_idx}(:, ind), u{obj_idx}(:, ind));
        
        % Calibrate
% %         K = rq(P);
% %         P = inv(K)*P;

        if abs(det(P(:,1:3)) - 1) < 10^-5
            continue
        end
        

        % Calculate number of inliers
       x = P*euclidian_to_homo(U{obj_idx});
       n_inliers = sum(root_error(pflat(x), u{obj_idx}) < threshold);

       % All the points are in front of the camera so if x(3) < 0 then
       % something's wrong
%        if any(x(3,:) < 0)
%             continue
%        end
       
       if n_inliers > n_inliers_max
          n_inliers_max = n_inliers;
          P_best = P;
       end


    end
    
%     % Get the inliers
%     x = P_best * euclidian_to_homo(U{obj_idx});
%     inlier_idx = root_error(pflat(x), u{obj_idx}) < threshold;
%     inliers = U{obj_idx}(:,inlier_idx);

    % Get the array of where the inliers are    
    x = P_best * euclidian_to_homo(U{obj_idx});
    inlier_idx = root_error(pflat(x), u{obj_idx}) < threshold;
    inliers = inlier_idx;
    
%     Calibrate camera
    K = rq(P_best);
    P_best = inv(K)*P_best;
     

end

























